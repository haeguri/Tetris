<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        .container {
            position: relative;
        }

        * {
            -webkit-box-sizing: border-box;
            -moz-box-sizing: border-box;
            box-sizing: border-box;
            font-family: "Nanum Gothic";
        }

        .container {
            width: 400px;
            margin-left:auto;
            margin-right:auto;
        }

        #board {
            position: relative;
            /*width:220px;*/
            width:200px;
            height:auto;
            display: inline-block;
        }

        /*#board .row:nth-of-type(1) {*/
            /*display: none;*/
        /*}*/

        #next {
            height: auto;
            width: 120px;
            display: inline-block;
            text-align: center;
        }

        #next .row {
            width:80px;
            margin-right:auto;
            margin-left:auto;
        }

        #next .cell {
            border: solid 1px #cccccc;
        }

        .cell {
            border:solid 1px #cccccc;
            height:20px;
            width:20px;
            float:left;
            display:inline-block;
        }
        
        .row-label, .col-label {
            text-align: center;
        }

        .row-label {
            display: inline-block;
            height:20px;
            width:20px;
            float: left;
        }

        .col-label {
            display: inline-block;
            height:20px;
            width:20px;
            float: right;
        }

        #game-over.show {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 10;
            width:100%;
            height:100%;
            background-color: rgba(0,0,0,0.9);
            color: white;
        }

        #game-over{
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .hide {
            display: none !important;
        }

    </style>
    <link rel="stylesheet" href="./bower_components/NanumGothic/NanumGothic.css">
</head>
<body>
<div class="container">
    <div id="board">
    </div>
    <div id="next">
        <h3>Next</h3>
    </div>
</div>
<div id="game-over" class="hide">
    <h1>Game Over</h1>
    <button>이름 입력하기</button>
    <button>다시 시작하기</button>
</div>
<script src="./setting.js"></script>
<script>
    (function(setData) {
        'use strict';

        var MAX_COL_NUM = setData.maxColNum;
        var MAX_ROW_NUM = setData.maxRowNum;
        var NEXT_MAX_COL_NUM = setData.nextMaxColNum;
        var NEXT_MAX_ROW_NUM = setData.nextMaxRowNum;
        var START_ROW = setData.startRow;
        var START_COL = setData.startCol;
        var SPACE_KEY = setData.spaceKeyCode;
        var LEFT_KEY = setData.leftKeyCode;
        var RIGHT_KEY = setData.rightKeyCode;
        var UP_KEY = setData.upKeyCode;
        var DOWN_KEY = setData.downKeyCode;

        var blockSet = setData.blockSet;
        var boardMap = [];

        var movingBlock = {
            'rotationSet':[],
            'next':undefined,
            'cur':{
                'idx':0,
                'block':[],
                'pivot':[],
                'color':''
            },
            'rotate':function() {
                    var nextIdx = (this.cur.idx + 1) % (this.rotationSet.length);

                    var nextRotBlock = {
                        'pivot':[],
                        'block':[]
                    };

                    for(var i = 0; i < this.rotationSet[nextIdx].length; i++) {
                        nextRotBlock.block.push(this.rotationSet[nextIdx][i].slice());
                    }

                    for(i = 0; i < nextRotBlock.block.length; i++) {
                        nextRotBlock.block[i][0] += this.cur.pivot[0];
                        nextRotBlock.block[i][1] += this.cur.pivot[1];
                    }

                    nextRotBlock.pivot[0] = this.cur.pivot[0];
                    nextRotBlock.pivot[1] = this.cur.pivot[1];

                    var overCells = [];

                    for(i = 0; i < nextRotBlock.block.length; i++) {
                        if(nextRotBlock.block[i][1] >= MAX_COL_NUM || nextRotBlock.block[i][0] >= MAX_ROW_NUM || nextRotBlock.block[i][1] < 0) {
                            console.log("매트릭스 범위를 벗어났다.");
                            overCells.push([nextRotBlock.block[i][0], nextRotBlock.block[i][1]]);

                        } else if(boardMap[nextRotBlock.block[i][0]][nextRotBlock.block[i][1]] === 1) {
                            overCells.push([nextRotBlock.block[i][0], nextRotBlock.block[i][1]]);
                            console.log("쌓인 블록과 충돌 ::" + nextRotBlock.block[i][0] + ", " + nextRotBlock.block[i][1]);
                        }
                    }


                    var canRotate = false;
                    if(overCells.length === 0) {
                        console.log('충돌없음. 회전.');
                        this.cur.idx += 1;
                        this.cur.block = [];
                        for(i = 0; i < nextRotBlock.block.length; i++) {
                            this.cur.block.push([].concat(nextRotBlock.block[i]));
                        }

                    } else if(overCells.length === 1) {
                        console.log("충돌 길이 : " + overCells.length);
                        if(canBlockMove(nextRotBlock.block, 'left', 1)) {
                            console.log('좌로 이동가능');
                            moveBlockCoord(nextRotBlock, 'left', 1);

                        } else if(canBlockMove(nextRotBlock.block, 'right', 1)) {
                            console.log('우로 이동가능');
                            moveBlockCoord(nextRotBlock, 'right', 1);

                        } else if(canBlockMove(nextRotBlock.block, 'up', 1)) {
                            console.log('위로 이동가능');
                            moveBlockCoord(nextRotBlock, 'up', 1);

                        } else if(canBlockMove(nextRotBlock.block, 'down', 1)) {
                            console.log("하로 이동가능");
                            moveBlockCoord(nextRotBlock, 'down', 1);

                        } else {
                            console.log("회전된 블락은 이동할 공간 없음.");
                            return;
                        }

                        this.cur.idx += 1;
                        this.cur.block = [];

                        for(i = 0; i < nextRotBlock.block.length; i++) {
                            this.cur.block.push([].concat(nextRotBlock.block[i]));
                        }

                        this.cur.pivot[0] = nextRotBlock.pivot[0];
                        this.cur.pivot[1] = nextRotBlock.pivot[1];

                    } else if(overCells.length >= 2) {

                        var temp = {
                            'block':[],
                            'pivot':[]
                        };

                        for(i = 0; i < nextRotBlock.block.length; i++) {
                            temp.block.push([].concat(nextRotBlock.block[i]));
                        }

                        console.log("충돌 길이 : " + overCells.length);
                        for(var cnt = 1; cnt <= overCells.length; cnt++) {
                            if(temp.block.length !== 0 ) { temp.block = []; }

                            for(i = 0; i < nextRotBlock.block.length; i++) {
                                temp.block.push([].concat(nextRotBlock.block[i]));
                            }

                            temp.pivot[0] = nextRotBlock.pivot[0];
                            temp.pivot[1] = nextRotBlock.pivot[1];

                            if(canBlockMove(nextRotBlock.block, 'left', cnt)) {
                                console.log('좌로 이동가능');
                                moveBlockCoord(nextRotBlock, 'left', cnt);
                                canRotate = true;
                                break;
                            } else if(canBlockMove(nextRotBlock.block, 'right', cnt)) {
                                console.log('우로 이동가능');
                                moveBlockCoord(nextRotBlock, 'right', cnt);
                                canRotate = true;
                                break;
                            } else if(canBlockMove(nextRotBlock.block, 'up', cnt)) {
                                console.log('위로 이동가능');
                                moveBlockCoord(nextRotBlock, 'up', cnt);
                                canRotate = true;
                                break;
                            } else if(canBlockMove(nextRotBlock.block, 'down', cnt)) {
                                console.log("하로 이동가능");
                                moveBlockCoord(nextRotBlock, 'down', cnt);
                                canRotate = true;
                                break;
                            }
                        }

                        if(i !== overCells.length && canRotate) {
                            this.cur.idx += 1;
                            this.cur.block = [];

                            for(i = 0; i < nextRotBlock.block.length; i++) {
                                this.cur.block.push(nextRotBlock.block[i].slice());
                            }

                            this.cur.pivot = nextRotBlock.pivot.slice();

                        } else {
                            console.log("회전을 시도 했지만 이동할 각이 안나온다. 회전 안되겠다.");
                        }
                    } else {
                        console.log("회전 안됨.");
                    }
            }
        };


        function getElem(key, type) {
            if(type == 'id') {
                return document.getElementById(key);
            }
        }

        function getElemByCoord(row, col) {
            return getElem('cell-' + row + '-' + col, 'id');
        }

        function initBoard(){
            var board = getElem('board', 'id');
            var cell;
            var row, col;
            var row_elem;

            if(setData.debug) {
                var t;
                for(col = MAX_COL_NUM-1; col >= 0; col--) {
                    t = document.createElement('div');
                    t.innerText = col+'';
                    t.className = 'col-label';
                    board.appendChild(t);
                }
            }

            var next = getElem('next', 'id');

            for(row = 0; row < NEXT_MAX_ROW_NUM; row++) {
                row_elem = document.createElement('div');
                row_elem.className = 'row';
                next.appendChild(row_elem);
                for(col = 0; col < NEXT_MAX_COL_NUM; col++) {
                    cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.id = 'next-'+row+'-'+col;
                    row_elem.appendChild(cell);
                }
            }

            for(row = 0; row < MAX_ROW_NUM; row++) {
                if(setData.debug) {
                    t = document.createElement('div');
                    t.className = 'row-label';
                    t.innerText = row;

                    board.appendChild(t);
                }

                row_elem = document.createElement('div');
                if(!setData.debug && row <= setData.hideRow) {
                    row_elem.className = 'row hide';
                } else {
                    row_elem.className = 'row';
                }
                board.appendChild(row_elem);
                for(col = 0; col < MAX_COL_NUM; col++) {
                    cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.id = 'cell-' + row + '-' + col;
                    row_elem.appendChild(cell);
                }
            }

            for(row = 0; row < MAX_ROW_NUM; row++) {
                boardMap[row] = [];
                for(col = 0; col < MAX_COL_NUM; col++) {
                    boardMap[row][col] = 0;
                }
            }

            generateBlock();
        }

        function generateBlock() {
            // 랜덤 인덱스 생성.
            var blockSetIdx;
            if(movingBlock.next === undefined) {
                console.log('1');
                blockSetIdx = Math.floor(Math.random()*blockSet.length);
            } else {
                console.log('2');
                removeNextBlock(setData.blockSet[movingBlock.next][0]);
                blockSetIdx = movingBlock.next;
            }

            movingBlock.next = Math.floor(Math.random()*blockSet.length);

            console.log('cur  block : ', blockSetIdx);
            console.log('next block : ', movingBlock.next);

            var color = setData.colorSet[blockSetIdx];

            if(movingBlock.cur.block.length !== 0) {
                movingBlock.cur.block = [];
                movingBlock.cur.idx = 0;
                movingBlock.cur.pivot = [];
                movingBlock.cur.color = '';
                movingBlock.rotationSet = [];
            }

            // 변수 block에 저장할 블락셋 중에 하나를 선택한다. 지금은 하나의 블락으로만 테스트.
            // movingBlock.cur.block 렌더링될 블락이 담겨있다.
            for(var i = 0; i < blockSet[blockSetIdx][movingBlock.cur.idx].length; i++) {
                movingBlock.cur.block.push([].concat(blockSet[blockSetIdx][movingBlock.cur.idx][i]));
            }

            // movingBlock.rotation에는 movingBlock.cur.block이 회전할 수 있는 블락의 모든 블락이 있다
            for(var i = 0; i < blockSet[blockSetIdx].length; i++) {
//          하나의 블락을 순회하며 셀의 위치를 복사한다.
                var temp = [];
                for(var j = 0; j < blockSet[blockSetIdx][i].length; j++) {
                    temp.push([].concat(blockSet[blockSetIdx][i][j]));
                }
                movingBlock.rotationSet.push(temp);
            }

            // 시작 위치에 블락을 그리기 위해서 블락의 위치를 조정해준다.
            for(var i = 0; i < movingBlock.cur.block.length; i++) {
                movingBlock.cur.block[i][0] += START_ROW;
                movingBlock.cur.block[i][1] += START_COL;
            }

            movingBlock.cur.pivot[0] = START_ROW;
            movingBlock.cur.pivot[1] = START_COL;
            movingBlock.cur.color = color;

            renderBlock(movingBlock.cur.block, movingBlock.cur.color);
            renderNextBlock(setData.blockSet[movingBlock.next][0], setData.colorSet[movingBlock.next]);
        }

        function renderNextBlock(bl, color){
            var cell;
            for(var i = 0; i < bl.length; i++) {
                cell = getElem('next-'+bl[i][0]+'-'+bl[i][1], 'id');
                cell.style.cssText = 'background-color:'+color;
            }
        }

        function removeNextBlock(bl) {
            var cell;
            for(var i = 0; i < bl.length; i++) {
                cell = getElem('next-'+bl[i][0]+'-'+bl[i][1], 'id');
                cell.style.cssText = 'background-color:'+'none;';
            }
        }

        function moveBlockCoord(bl, type, cnt) {
            // rotPivot이 matrix의 크기를 넘어갈 경우 대응?
            if(type === 'down') {
                bl.pivot[0] += cnt;
            } else if(type === 'left') {
                bl.pivot[1] -= cnt;
            } else if(type === 'right') {
                bl.pivot[1] += cnt;
            } else if(type === 'up') {
                bl.pivot[0] -= cnt;
            }

            for(var i = 0; i < bl.block.length; i++) {
                bl.block[i] = moveCellCoord(bl.block[i][0], bl.block[i][1], type, cnt);
            }

            return bl.block;
        }

        function moveLineCoord(bl) {
            var new_line = [];
            var temp_cell;
            for(var i = 0; i < bl.length; i++) {
                temp_cell = moveCellCoord(bl[i][0], bl[i][1], 'down', 1);
                temp_cell.push(bl[i][2]);
                new_line.push(temp_cell);
            }

            return new_line;
        }

        function moveCellCoord(row, col, type, cnt) {
            if(type === 'down') {
                row += cnt;
            } else if(type === 'left') {
                col -= cnt;
            } else if( type === 'right') {
                col += cnt;
            } else if( type === 'up') {
                row -= cnt;
            }
            return [row, col];
        }

        function removeBlock(bl, dir) {
            var cell;
            for(var i = 0; i < bl.length; i++) {
                if(dir == 'down') {
                    cell = getElemByCoord(bl[i][0]-1, bl[i][1]);
                }
                else if(dir == 'left') {
                    cell = getElemByCoord(bl[i][0], bl[i][1]+1);
                }
                else if(dir == 'right') {
                    cell = getElemByCoord(bl[i][0], bl[i][1]-1);
                }
                else if(dir == 'rotate' || dir == 'hardDown' || dir == 'break') {
                    cell = getElemByCoord(bl[i][0], bl[i][1]);
                }

                cell.style.cssText = 'background-color:'+'none;';
            }
        }

        // 블락을 그린다.
        function renderBlock(bl, color) {
            var cell;
            for(var i = 0; i < bl.length; i++) {
                cell = getElemByCoord(bl[i][0], bl[i][1]);

                if(!color) {
                    cell.style.cssText = 'background-color:'+bl[i][2];
                } else {
                    cell.style.cssText = 'background-color:'+color;
                }
            }
        }

        function canBlockMove(bl, type, cnt) {
            var row, col;

            for(var i = 0; i < bl.length; i++) {
                if(type === 'down') {
                    row = bl[i][0] + cnt;
                    col = bl[i][1]
                }else if(type === 'left') {
                    row = bl[i][0];
                    col = bl[i][1] - cnt
                }else if(type === 'right') {
                    row = bl[i][0];
                    col = bl[i][1] + cnt;
                }else if(type === 'up') {
                    row = bl[i][0] - cnt;
                    col = bl[i][1];
                }

                if(row < 0 || row >= MAX_ROW_NUM || col < 0 || col >= MAX_COL_NUM || boardMap[row][col] === 1) {
                    return false;
                }
            }
            return true;
        }

        function gameOver() {
            var gameOverElem = getElem('game-over', 'id');
            gameOverElem.className = 'show';
        }

        function putBlock() {
            var row, col, i;
            for(i = 0; i < movingBlock.cur.block.length; i++) {
                boardMap[movingBlock.cur.block[i][0]][movingBlock.cur.block[i][1]] = 1;
            }

            for(row = 3; row >= 0; row--) {
               for(col = 0; col < MAX_COL_NUM; col++) {
                    if(boardMap[row][col] == 1){
                        gameOver();
                        clearInterval(tic);
                        return;
                    }
               }
            }

            // 블락이 어디에 꽂혔는지 (몇행 몇행 에 꽂혔는지 검사한다.)
            var breakingRows = [];

            for(i = 0; i < movingBlock.cur.block.length; i++) {
                if(breakingRows.indexOf(movingBlock.cur.block[i][0]) === -1) {
                    breakingRows.push(movingBlock.cur.block[i][0]);
                }
            }

            for(i = 0; i < movingBlock.cur.block.length; i++) {
                boardMap[movingBlock.cur.block[i][0]][movingBlock.cur.block[i][1]] = 1;
            }

            breakingRows = breakingRows.filter(function(row){
                if(boardMap[row].indexOf(0) === -1) {
                    return row;
                }
            });

            if(breakingRows.length > 0) {
                breakingRows.sort();
                // 부숴져야 할 행을 구했다.
                // 이제 부숴져야 할 행들을 boardMap과 html view에서 삭제 처리한다.
                var breakingLine;

                for(i = breakingRows.length-1; i >= 0; i--) {
                    breakingLine = [];

                    // boardMap에서 삭제 처리.
                    for(col = 0; col < MAX_COL_NUM; col++) {
                        boardMap[breakingRows[i]][col] = 0;

                        // removeBlock으로 view에서 삭제 처리.
                        // removeBlock은 쉘([row, col]) 배열 형태[[row,col],[row,col....],...]의 매개변수만 처리 가능.
                        breakingLine.push([breakingRows[i],col]);
                    }

                    removeBlock(breakingLine, 'break');
                }

                // 부셔야할 행을 찾았다.. (부숴진 행을 제외한) 나머지 행들을 아래서부터 끌어내린다.

                var color;
                var dropLineInfo = [];

                for(row = MAX_ROW_NUM - 1; row >= 0; row--) {
                    if(breakingRows.indexOf(row) === -1) {
                        for(col = 0; col < MAX_COL_NUM; col++) {
                            color = getElemByCoord(row, col).style.backgroundColor;
                            dropLineInfo.push([row, col, color]);
                        }

                        removeBlock(dropLineInfo, 'break');
                        for(var i = 0; i < dropLineInfo.length; i++) {
                            boardMap[dropLineInfo[i][0]][dropLineInfo[i][1]] = 0;
                        }

                        while(canBlockMove(dropLineInfo, 'down', 1)) {
                            dropLineInfo = moveLineCoord(dropLineInfo);
                        }

                        renderBlock(dropLineInfo);

                        for(var i = 0; i < dropLineInfo.length; i++) {
                            if(dropLineInfo[i][2] !== "") {
                                boardMap[dropLineInfo[i][0]][dropLineInfo[i][1]] = 1;
                            }
                        }

                        dropLineInfo = [];
                    }
                }
            }
        }

        document.body.onkeydown = function(e) {
            switch (e.keyCode) {
                case LEFT_KEY:
//                    console.log("left key");
                    if(canBlockMove(movingBlock.cur.block, 'left', 1)) {
                        moveBlockCoord(movingBlock.cur, 'left', 1);
                        removeBlock(movingBlock.cur.block, 'left');
                        renderBlock(movingBlock.cur.block, movingBlock.cur.color);
                    }
                    break;

                case RIGHT_KEY:
//                    console.log("right key");
                    if(canBlockMove(movingBlock.cur.block, 'right', 1)) {
                        moveBlockCoord(movingBlock.cur, 'right', 1);
                        removeBlock(movingBlock.cur.block, 'right');
                        renderBlock(movingBlock.cur.block, movingBlock.cur.color);
                    }
                    break;

                case DOWN_KEY:
//                    console.log("down key");
                    if(canBlockMove(movingBlock.cur.block, 'down', 1)) {
                        moveBlockCoord(movingBlock.cur, 'down', 1);
                        removeBlock(movingBlock.cur.block, 'down');
                        renderBlock(movingBlock.cur.block, movingBlock.cur.color);
                    }
                    break;

                case UP_KEY:
                    removeBlock(movingBlock.cur.block, 'rotate');
                    movingBlock.rotate();
                    renderBlock(movingBlock.cur.block, movingBlock.cur.color);
                    break;

                case SPACE_KEY:
//                    console.log("space key");
                    removeBlock(movingBlock.cur.block, 'hardDown');
                    while(canBlockMove(movingBlock.cur.block, 'down', 1)) {
                        moveBlockCoord(movingBlock.cur, 'down', 1);
                    }
                    renderBlock(movingBlock.cur.block, movingBlock.cur.color);
                    putBlock();
                    generateBlock();

                    break;
                default:
                    break;

            }
        };

        var tic = setInterval(function() {
            if(canBlockMove(movingBlock.cur.block, 'down', 1)) {
                moveBlockCoord(movingBlock.cur, 'down', 1);
                removeBlock(movingBlock.cur.block, 'down');
                renderBlock(movingBlock.cur.block, movingBlock.cur.color);
            } else {
                putBlock();
                generateBlock();

            }
        }, 1000);


        initBoard();

    }(globalSetData));
</script>
</body>
</html>